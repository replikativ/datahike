{:min-bb-version "0.8.0"
 :pods {org.babashka/tools-deps-native {:version "0.1.7"}
        clj-kondo/clj-kondo {:version "2025.07.28"}}
 :deps {datahike/bb {:local/root "bb"}
        org.babashka/http-client {:mvn/version "0.4.22"}}
 :tasks {:requires [[babashka.fs :as fs]
                    [babashka.process :as process]
                    [clojure.edn :as edn]
                    [clojure.string :as str]
                    [pod.borkdude.clj-kondo :as clj-kondo]
                    [tools.build :as build]
                    [tools.clj-kondo :as clj-kondo-tools]
                    [tools.deploy :as deploy]
                    [tools.npm :as npm]
                    [tools.python :as python]
                    [tools.release :as release]
                    [tools.test :as test]
                    [tools.version :as version]]
         :init (do (def config-file "config.edn")
                   (def config (edn/read-string (slurp config-file))))

         ; tools

         bench {:doc "Run benchmarks"
                :depends [prep]
                :task (clojure "-M:benchmark" "measure")}

         ffix {:doc "Format source files"
               :depends [prep]
               :task (clojure "-M:ffix")}

         ; checks

         format {:doc "Test formatting"
                 :depends [prep]
                 :task (clojure "-M:format")}

         lint {:doc "Run clj-kondo linter"
               :require [[pod.borkdude.clj-kondo :as clj-kondo]]
               :task (clj-kondo/print! (clj-kondo/run! {:lint "."}))}

         test {:doc "Run all tests or restrict to 'native-image', 'back-compat' or a kaocha test id (see tests.edn)"
               :depends [jcompile]
               :task (apply test/-main config *command-line-args*)}

         kaocha {:doc "Run kaocha with arbitrary arguments"
                 :task (apply test/kaocha *command-line-args*)}


         outdated {:doc "Find outdated libraries"
                   :depends [prep]
                   :task (clojure "-M:outdated")}

         ; build and release

         inc {:doc "Increment the project version: [major|minor] <version>"
              :task (apply version/inc config-file *command-line-args*)}

         tag {:doc "Return current version as a tag"
              :task (println (version/as-tag config))}

         clean {:doc "Remove build files"
                :task (build/clean (-> config :build :clj))}

         prep {:doc "Prepare git dependencies (compile Java sources)"
               :task (clojure "-X:deps prep")}

         codegen-java {:doc "Generate Java API bindings from specification"
                       :depends [prep]
                       :task (let [cp (str/trim (:out (shell {:out :string} "clojure" "-Spath")))]
                               ;; First compile Java dependencies (Util, IEntity) so Clojure can load them
                               (println "Compiling Java dependencies...")
                               (shell "javac" "-cp" cp "-d" "target/classes"
                                      "java/src/datahike/java/IEntity.java"
                                      "java/src/datahike/java/Util.java")
                               ;; Now generate the Java API
                               (println "Generating Java API from specification...")
                               (clojure "-M" "-m" "datahike.codegen.java" "java/src-generated"))}

         codegen-ts {:doc "Generate TypeScript type definitions from specification"
                     :task (npm/generate-typescript-definitions! "npm-package/index.d.ts")}

         codegen-native {:doc "Generate native C entry points from specification"
                         :depends [prep]
                         :task (clojure "-M" "-m" "datahike.codegen.native" "libdatahike/src")}

         python-version {:doc "Update Python package version from config.edn"
                         :task (python/update-python-version! config "pydatahike")}

         codegen-python {:doc "Generate Python bindings from specification"
                         :depends [prep python-version]
                         :task (clojure "-M" "-m" "datahike.codegen.python" "pydatahike/src/datahike")}

         codegen-clj-kondo {:doc "Generate clj-kondo config from API specification"
                            :depends [prep]
                            :task (clj-kondo-tools/generate-clj-kondo-config!
                                    "resources/clj-kondo.exports/io.replikativ/datahike/config.edn"
                                    ".clj-kondo/datahike/datahike/config.edn"
                                    ".clj-kondo/config.edn")}

         codegen-all {:doc "Generate all language bindings (TypeScript, Java, Native, Python)"
                      :depends [codegen-ts codegen-java codegen-native codegen-python]}

         codegen-report {:doc "Show code generation coverage across all bindings"
                         :depends [prep]
                         :task (clojure "-M" "-m" "datahike.codegen.report")}

         jcompile {:doc "Compile java classes"
                   :depends [clean codegen-java]
                   :task (build/compile-java (-> config :build :clj))}

         ccompile {:doc "Compile clojure namespaces"
                   :task (build/compile-clojure (-> config :build :clj))}

         version-resource {:doc "Generate version resource file for embedding in builds"
                           :task (build/write-version-resource config)}

         pom {:doc "Create pom file"
              :task (build/pom config (-> config :build :clj))}

         jar {:doc "Build jar"
              :depends [jcompile pom version-resource]
              :task (build/jar config (-> config :build :clj))}

         install {:doc "Install jar locally"
                  :task (deploy/local config (-> config :build :clj))}

         clojars {:doc "Install jar to clojars"
                  :task (deploy/remote config (-> config :build :clj))}

         release {:doc "Build and release jar to GitHub"
                  :task (release/-main config *command-line-args*)}


         ;; http server build and release

         http-server-clean {:doc  "Remove build files"
                            :task (build/clean (-> config :build :http-server-clj))}

         http-server-jcompile {:doc     "Compile java classes"
                               :depends [http-server-clean]
                               :task    (build/compile-java (-> config :build :http-server-clj))}

         http-server-ccompile {:doc  "Compile clojure namespaces for http-server"
                               :task (build/compile-clojure (-> config :build :http-server-clj))}

         http-server-pom {:doc  "Create pom file"
                          :task (build/pom config (-> config :build :http-server-clj))}

         http-server-uber {:doc     "Build jar"
                           :depends [http-server-jcompile http-server-pom http-server-ccompile version-resource]
                           :task    (build/uber config (-> config :build :http-server-clj))}

         http-server-install {:doc  "Install uber jar locally"
                              :task (deploy/local config (-> config :build :http-server-clj))}

         http-server-release {:doc     "Build and release jar to GitHub"
                              :depends [http-server-uber]
                              :task    (let [jar (build/jar-path config (-> config :build :http-server-clj))]
                                         (release/gh-release jar config))}

         ;; native image

         ni-check {:doc "Check for 'native-image' program"
                   :task (try (shell "which" "native-image")
                              (println "Program native-image found!")
                              (catch Exception _
                                (println "PATH does not contain native-image! Make sure to add your GraalVM to it.")
                                (System/exit 1)))}

         ni-cli {:doc "Build native image cli"
                 :depends [jcompile ni-check version-resource]
                 :task (clojure "-M:native-cli")}

         ni-ccompile {:doc "Compile clojure namespaces for native-image"
                      :depends [jcompile]
                      :task (build/compile-clojure (-> config :build :native))}

         ni-uber {:doc "Build native image uber jar"
                  :depends [jcompile ni-ccompile version-resource]
                  :task (build/uber config (-> config :build :native))}

         ni-compile {:doc "Create native cpp library"
                     :depends [ni-uber]
                     :task (build/native-compile config (-> config :build :native))}

        ;; npm package

         npm-version {:doc "Update npm package.json version from config.edn"
                      :task (npm/update-package-json-version! config "npm-package")}

         npm-clean {:doc "Clean compiled files from npm package directory"
                    :task (npm/clean-npm-package! "npm-package")}

         npm-build {:doc "Build npm package (clean, update version, generate types, compile ClojureScript)"
                    :depends [prep]
                    :task (npm/build-npm-package! config "npm-package")}

         npm-test {:doc "Run npm package JavaScript tests"
                   :task (do
                           (println "Running npm package tests...")
                           (let [result (shell {:dir "npm-package"
                                                :out :inherit
                                                :err :inherit}
                                               "node test.js")]
                             (when-not (zero? (:exit result))
                               (System/exit 1))))}

         node-cljs-test {:doc "Compile and run ClojureScript tests on Node.js"
                         :depends [prep]
                         :task (do
                                 (println "Compiling CLJS node tests...")
                                 (shell "npx shadow-cljs compile node-test")
                                 (println "Running CLJS node tests...")
                                 (shell "node target/out/node-test.js"))}

         browser-test {:doc "Run browser integration tests with Karma (headless Chrome)"
                       :depends [prep]
                       :task (let [;; Auto-detect Chrome binary
                                   chrome-bin (or (System/getenv "CHROME_BIN")
                                                  (when (fs/exists? "/usr/bin/chromium-browser") "/usr/bin/chromium-browser")
                                                  (when (fs/exists? "/usr/bin/chromium") "/usr/bin/chromium")
                                                  (when (fs/exists? "/usr/bin/google-chrome") "/usr/bin/google-chrome"))]
                               (when-not chrome-bin
                                 (println "ERROR: Chrome not found. Set CHROME_BIN environment variable.")
                                 (System/exit 1))

                               ;; Start JVM test server in background
                               (println "Starting Kabel test server on ws://localhost:47296...")
                               (let [server-proc (process/process
                                                  ["clojure" "-M:test" "-e"
                                                   "(require 'datahike.kabel.browser-test-server) (datahike.kabel.browser-test-server/start-test-server!) (Thread/sleep Long/MAX_VALUE)"]
                                                  {:out :inherit :err :inherit})]
                                 (try
                                   ;; Wait for server to start
                                   (println "Waiting for server startup (10s)...")
                                   (Thread/sleep 10000)

                                   ;; Compile browser tests
                                   (println "Compiling browser tests...")
                                   (shell "npx shadow-cljs compile browser-ci")

                                   ;; Run Karma
                                   (println "Running tests with Karma...")
                                   (shell {:extra-env {"CHROME_BIN" chrome-bin}} "npx karma start --single-run")

                                   (finally
                                     ;; Kill the server process
                                     (println "Stopping test server...")
                                     (process/destroy-tree server-proc)))))}

         browser-watch {:doc "Start browser test dev server (open http://localhost:8022)"
                        :depends [prep]
                        :task (do
                                (println "Starting browser test dev server...")
                                (println "Open http://localhost:8022 in your browser")
                                (shell "npx shadow-cljs watch browser-integration-test"))}

         ;; aggregate tasks

         ci {:doc "Run CI checks (Clojure/ClojureScript + npm tests)"
             :depends [test npm-test format lint]}}}
