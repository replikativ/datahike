;; clj-kondo export configuration for Datahike
;; AUTO-GENERATED from api-specification
;; To regenerate: bb codegen-clj-kondo

{:var-definitions {datahike.api {unlisten {:arglists (quote ([arg0 arg1])), :doc "Removes registered listener from connection."}, delete-database {:arglists (quote ([arg0] [])), :doc "Deletes a database given via configuration map."}, pull {:arglists (quote ([arg0 arg1] [arg0 arg1 arg2])), :doc "Fetches data using recursive declarative pull pattern."}, entity {:arglists (quote ([arg0 arg1])), :doc "Retrieves an entity by its id. Returns lazy map-like structure."}, metrics {:arglists (quote ([arg0])), :doc "Returns database metrics (datom counts, index sizes, etc)."}, reverse-schema {:arglists (quote ([arg0])), :doc "Returns reverse schema definition (attribute id to ident mapping)."}, datoms {:arglists (quote ([arg0 arg1] [arg0 arg1 arg2])), :doc "Index lookup. Returns sequence of datoms matching index components."}, load-entities {:arglists (quote ([arg0 arg1])), :doc "Load entities directly (bulk load)."}, is-filtered {:arglists (quote ([arg0])), :doc "Returns true if database was filtered using filter, false otherwise."}, q {:arglists (quote ([arg0] [arg0 arg1])), :doc "Executes a datalog query."}, schema {:arglists (quote ([arg0])), :doc "Returns current schema definition."}, index-range {:arglists (quote ([arg0 arg1])), :doc "Returns part of :avet index between start and end values."}, pull-many {:arglists (quote ([arg0 arg1] [arg0 arg1 arg2])), :doc "Same as pull, but accepts sequence of ids and returns sequence of maps."}, since {:arglists (quote ([arg0 arg1])), :doc "Returns database state since given time point (Date or transaction ID). Contains only datoms added since that point."}, query-stats {:arglists (quote ([arg0] [arg0 arg1])), :doc "Executes query and returns execution statistics."}, entity-db {:arglists (quote ([arg0])), :doc "Returns database that entity was created from."}, gc-storage {:arglists (quote ([arg0 arg1] [arg0])), :doc "Invokes garbage collection on connection's store. Removes old snapshots before given time point."}, create-database {:arglists (quote ([arg0] [])), :doc "Creates a database via configuration map."}, db {:arglists (quote ([arg0])), :doc "Returns the underlying immutable database value from a connection. Prefer using @conn directly."}, connect {:arglists (quote ([arg0] [arg0 arg1] [])), :doc "Connects to a Datahike database via configuration map."}, release {:arglists (quote ([arg0])), :doc "Releases a database connection."}, history {:arglists (quote ([arg0])), :doc "Returns full historical state of database including all assertions and retractions."}, transact! {:arglists (quote ([arg0 arg1])), :doc "Same as transact, but asynchronously returns a future."}, database-exists? {:arglists (quote ([arg0] [])), :doc "Checks if a database exists via configuration map."}, transact {:arglists (quote ([arg0 arg1])), :doc "Applies transaction to the database and updates connection."}, as-of {:arglists (quote ([arg0 arg1])), :doc "Returns database state at given time point (Date or transaction ID)."}, seek-datoms {:arglists (quote ([arg0 arg1] [arg0 arg1 arg2])), :doc "Like datoms, but returns datoms starting from specified components through end of index."}, filter {:arglists (quote ([arg0 arg1])), :doc "Returns filtered view over database. Only includes datoms where (pred db datom) is true."}, listen {:arglists (quote ([arg0 arg1] [arg0 arg1 arg2])), :doc "Listen for changes on connection. Callback called with transaction report on each transact."}, db-with {:arglists (quote ([arg0 arg1])), :doc "Applies transaction to immutable db value, returns new db. Same as (:db-after (with db tx-data))."}, with {:arglists (quote ([arg0 arg1] [arg0 arg1] [arg0 arg1 arg2])), :doc "Applies transaction to immutable db value. Returns transaction report."}, tempid {:arglists (quote ([arg0] [arg0 arg1])), :doc "Allocates temporary id (negative integer). Prefer using negative integers directly."}}}, :linters {:type-mismatch {:namespaces {datahike.api {unlisten {:arities {2 {:args [:any :any], :ret :any}}}, delete-database {:arities {1 {:args [:any], :ret :any}, 0 {:args [], :ret :any}}}, pull {:arities {2 {:args [:any :any], :ret :any}, 3 {:args [:any :vector :any], :ret :any}}}, entity {:arities {2 {:args [:any :any], :ret :any}}}, metrics {:arities {1 {:args [:any], :ret :any}}}, reverse-schema {:arities {1 {:args [:any], :ret :any}}}, datoms {:arities {2 {:args [:any :any], :ret :any}, 3 {:args [:any :keyword :any], :ret :any}}}, load-entities {:arities {2 {:args [:any :any], :ret :any}}}, is-filtered {:arities {1 {:args [:any], :ret :boolean}}}, q {:arities {1 {:args [:any], :ret :any}, 2 {:args [:any :any], :ret :any}}}, schema {:arities {1 {:args [:any], :ret :any}}}, index-range {:arities {2 {:args [:any :any], :ret :any}}}, pull-many {:arities {2 {:args [:any :any], :ret :seqable}, 3 {:args [:any :vector :any], :ret :seqable}}}, since {:arities {2 {:args [:any :any], :ret :any}}}, query-stats {:arities {1 {:args [:any], :ret :any}, 2 {:args [:any :any], :ret :any}}}, entity-db {:arities {1 {:args [:any], :ret :any}}}, gc-storage {:arities {2 {:args [:any :any], :ret :any}, 1 {:args [:any], :ret :any}}}, create-database {:arities {1 {:args [:any], :ret :any}, 0 {:args [], :ret :any}}}, db {:arities {1 {:args [:any], :ret :any}}}, connect {:arities {1 {:args [:any], :ret :any}, 2 {:args [:any :any], :ret :any}, 0 {:args [], :ret :any}}}, release {:arities {1 {:args [:any], :ret :nil}}}, history {:arities {1 {:args [:any], :ret :any}}}, transact! {:arities {2 {:args [:any :any], :ret :any}}}, database-exists? {:arities {1 {:args [:any], :ret :boolean}, 0 {:args [], :ret :boolean}}}, transact {:arities {2 {:args [:any :any], :ret :any}}}, as-of {:arities {2 {:args [:any :any], :ret :any}}}, seek-datoms {:arities {2 {:args [:any :any], :ret :any}, 3 {:args [:any :keyword :any], :ret :any}}}, filter {:arities {2 {:args [:any :any], :ret :any}}}, listen {:arities {2 {:args [:any :any], :ret :any}, 3 {:args [:any :any :any], :ret :any}}}, db-with {:arities {2 {:args [:any :any], :ret :any}}}, with {:arities {2 {:args [:any :any], :ret :any}, 3 {:args [:any :any :any], :ret :any}}}, tempid {:arities {1 {:args [:any], :ret :any}, 2 {:args [:any :int], :ret :int}}}}}}}}
